 The sliding window is a powerful and efficient algorithmic technique used for problems that involve a contiguous sequence of elements,
 like an array or a string. The main goal of this approach is to transform a slow, brute-force solution that uses nested loops 
 (often with a time complexity of O(nÂ²)) into a much faster solution that only requires a single pass (O(n) time complexity).

The Core Concept
Imagine you have a long list of numbers and you need to find the maximum sum of any three consecutive numbers.

The Brute-Force Way: You would first sum up elements at index 0, 1, and 2. Then, you'd start over and sum up elements at index 1, 2, and 3. 
Then 2, 3, and 4, and so on. Notice how you are re-calculating the sum of numbers that were already included in the previous step.

The Sliding Window Way: You calculate the sum of the first three elements (this is your initial "window"). To find the sum of the next 
three elements, you don't start from scratch. Instead, you "slide" the window one position to the right by:

Subtracting the element that just left the window.

Adding the new element that just entered the window.

This way, you are reusing the previous computation and only performing two operations for each step, which is much faster.

How It Works: A Step-by-Step Example
Let's use the problem from our previous conversation: Find the maximum sum of a subarray of size k.

Problem: arr = {5, 2, -1, 0, 3}, k = 3

Establish the First Window: Calculate the sum of the first k elements.

Window: {5, 2, -1}

Sum: 5 + 2 + (-1) = 6

So far, the maximum sum is 6.

Slide the Window: Move the window one position to the right. The new window should be {2, -1, 0}.

Instead of re-adding 2 + (-1) + 0, we take the previous sum (6), subtract the element that left (5), and add the new element that entered (0).

New Sum: 6 - 5 + 0 = 1

Compare with the max sum: max(6, 1) is 6. The maximum sum is still 6.

Slide Again: Move the window again. The new window is {-1, 0, 3}.

Take the previous sum (1), subtract the element that left (2), and add the new element (3).

New Sum: 1 - 2 + 3 = 2

Compare with the max sum: max(6, 2) is 6. The maximum sum remains 6.

Since we've reached the end of the array, the final answer is 6. This single pass over the array is far more efficient than the 
nested loops in the brute-force approach