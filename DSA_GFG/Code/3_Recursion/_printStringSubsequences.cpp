#include <iostream>
using namespace std;
#include<vector>
#include <algorithm>

class Solution
{	
	private:
        void solve(string str, int i, string output, vector<string> &ans)
        {   
            if(i >= str.length())
            {
                ans.push_back(output);
                return;
            }

            // excluding string
            solve(str, i+1, output, ans);

             // including string
            char current_element = str[i];
            output.push_back(current_element);
            solve(str, i+1, output, ans);
        }
    public:

        
        vector <string> subsequences(string str)
        {

            int i = 0;
            string output = " ";
            vector<string>ans;
            solve(str, i, output, ans);
            return ans;
        }

		

};


	
int main() {
	
	Solution s;
	string str = "shu";

	vector<string> result =  s.subsequences(str);

	for (auto x : result)
	{
		cout<<x<<", ";

	}
	
	return 0;
}


// What the Code Does:
// It generates all subsequences of a given string.

// For input: "shu"
// It will output all combinations of characters by including or excluding each character.

// ðŸ” Key Concepts:
// What is a Subsequence?
// A subsequence of a string is a new string generated by deleting 0 or more characters without changing the relative order of the remaining characters.

// ðŸ”¹ "shu" has these subsequences:
// ["", "s", "h", "u", "sh", "su", "hu", "shu"]
// (In your code, thereâ€™s a small bug that adds a space, we'll fix it later.)

// âœ… Code Breakdown
// ðŸ”¸ Class & Function
// void solve(string str, int i, string output, vector<string>& ans)
// Recursive function with:

// str = original string

// i = current index in str

// output = current built subsequence

// ans = list of all subsequences

// ðŸ”¸ Base Case:
// if(i >= str.length()) {
//     ans.push_back(output);
//     return;
// }
// When we've processed all characters, store the current subsequence.

// ðŸ”¸ Recursive Steps:Each character has two choices:

// Exclude â†’ donâ€™t add to output

// Include â†’ add to output

// So this forms a binary recursion tree, generating all possible subsequences.

// ðŸ”¸ subsequences(string str)
// Starts the recursion:

// Starts at index 0

// Initializes output = " " (This is a mistake! Should be "")

// Calls solve

// ðŸ§ª Example Trace
// For str = "shu":

// | Step  | Output |
// | ----- | ------ |
// | ""    |        |
// | "u"   |        |
// | "h"   |        |
// | "hu"  |        |
// | "s"   |        |
// | "su"  |        |
// | "sh"  |        |
// | "shu" |        |

//  Time Complexity
// Letâ€™s assume the string length is n.

// At each index, you have 2 options: include or exclude â†’ 2^n recursive calls.

// Each recursive call builds a string (max length n), but copying in C++ is O(n) time per string in worst case.

// ðŸ”¸ Time Complexity:
// ðŸ‘‰ O(n Ã— 2^n)
// (2^n subsequences, each of max length n)

// ðŸ§  Space Complexity
// Recursion stack depth: O(n) (for n levels of recursion)

// Result storage:

// 2^n strings, each up to n characters

// ðŸ”¸ Space Complexity:
// ðŸ‘‰ O(n Ã— 2^n) (for storing subsequences)
// ðŸ‘‰ Plus O(n) auxiliary space for call stack



// | Aspect             | Value                               |
// | ------------------ | ----------------------------------- |
// | Problem            | Print all subsequences of a string  |
// | Approach           | Recursion + backtracking            |
// | Total subsequences | 2^n                                 |
// | Time Complexity    | O(n Ã— 2^n)                          |
// | Space Complexity   | O(n Ã— 2^n)                          |
// | Bug Fix            | Initialize output as `""` not `" "` |
